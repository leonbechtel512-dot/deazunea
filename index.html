import React, { useState, useEffect } from 'react';
import { 
  ArrowRight, Check, X, RefreshCw, ChevronLeft, 
  Network 
} from 'lucide-react';

// --- KONFIGURATION: EINFACHES BEISPIEL ---
// Szenario: Automat erkennt Wörter, die auf "10" enden.
// Ein Klassiker für den Einstieg.
const SIMPLE_NFA_CONFIG = {
  states: [0, 1, 2],
  alphabet: ['0', '1'],
  startState: 0,
  finalStates: [2],
  transitions: {
    // q0: Start. Wartet. Bei '1' kann es der Anfang der Endung sein -> q0 & q1
    0: { '0': [0],    '1': [0, 1] }, 
    // q1: Hat '1' gelesen. Braucht '0' zum Ende.
    1: { '0': [2],    '1': [] },     
    // q2: Hat '10' gelesen. (Endzustand). Sackgasse im NEA (oder Neustart).
    2: { '0': [],     '1': [] }    
  },
  // Positionen für die Grafik (Schön in einer Reihe)
  layout: {
    0: { x: 100, y: 200, label: 'q0' },
    1: { x: 250, y: 200, label: 'q1' },
    2: { x: 400, y: 200, label: 'q2' }
  }
};

// --- HILFSFUNKTIONEN ---

const formatSet = (set) => {
  if (!set || set.length === 0) return '∅';
  const sorted = [...set].sort((a, b) => a - b);
  return `{${sorted.map(s => `q${s}`).join(', ')}}`;
};

const areSetsEqual = (a, b) => {
  if (!a || !b) return false;
  if (a.length !== b.length) return false;
  const setA = new Set(a);
  return b.every(x => setA.has(x));
};

const calculateTarget = (sourceSet, symbol, config) => {
  const targetSet = new Set();
  if (!sourceSet) return [];
  sourceSet.forEach(s => {
    const targets = config.transitions[s]?.[symbol] || [];
    targets.forEach(t => targetSet.add(t));
  });
  return Array.from(targetSet).sort((a, b) => a - b);
};

// --- HAUPTKOMPONENTE ---

const NeaToDeaTrainer = () => {
  const [config] = useState(SIMPLE_NFA_CONFIG);
  
  // Lazy State Init gegen "undefined" Fehler beim Laden
  const [history, setHistory] = useState(() => {
    const startSet = [SIMPLE_NFA_CONFIG.startState];
    return [{
      discoveredStates: [startSet],
      queue: [0], 
      transitions: {},
      currentFocus: { stateIdx: 0, symbol: SIMPLE_NFA_CONFIG.alphabet[0] }
    }];
  });
  
  const [currentStepIndex, setCurrentStepIndex] = useState(0);
  const [userSelection, setUserSelection] = useState([]);
  const [feedback, setFeedback] = useState(null);
  const [isFinished, setIsFinished] = useState(false);

  // Reset
  const resetExercise = () => {
    const startSet = [config.startState];
    setHistory([{
      discoveredStates: [startSet],
      queue: [0],
      transitions: {},
      currentFocus: { stateIdx: 0, symbol: config.alphabet[0] }
    }]);
    setCurrentStepIndex(0);
    setUserSelection([]);
    setFeedback(null);
    setIsFinished(false);
  };

  const handleBack = () => {
    if (currentStepIndex > 0) {
      setCurrentStepIndex(prev => prev - 1);
      setFeedback(null);
      setUserSelection([]);
      setIsFinished(false);
    }
  };

  const currentState = history[currentStepIndex];
  // Sicherheits-Check falls Render schneller als State ist
  if (!currentState) return <div className="p-8 text-center">Laden...</div>;

  const { discoveredStates, queue, transitions, currentFocus } = currentState;

  const handleToggleState = (stateId) => {
    if (feedback?.type === 'success') return; 
    setUserSelection(prev => 
      prev.includes(stateId) ? prev.filter(id => id !== stateId) : [...prev, stateId].sort((a,b)=>a-b)
    );
  };

  const checkAnswer = () => {
    if (!currentFocus) return;

    const sourceSet = discoveredStates[currentFocus.stateIdx];
    const correctTarget = calculateTarget(sourceSet, currentFocus.symbol, config);

    if (areSetsEqual(userSelection, correctTarget)) {
      // Richtig
      const existingIdx = discoveredStates.findIndex(s => areSetsEqual(s, correctTarget));
      const isNew = existingIdx === -1;
      
      const nextDiscovered = [...discoveredStates];
      const nextQueue = [...queue]; // Kopie der aktuellen Queue
      let targetIdx = existingIdx;

      if (isNew) {
        nextDiscovered.push(correctTarget);
        targetIdx = nextDiscovered.length - 1;
        nextQueue.push(targetIdx); // Neuen Zustand hinten anfügen
      }

      const nextTransitions = {
        ...transitions,
        [currentFocus.stateIdx]: {
          ...(transitions[currentFocus.stateIdx] || {}),
          [currentFocus.symbol]: targetIdx
        }
      };

      // Nächsten Fokus berechnen
      const symbols = config.alphabet;
      const currentSymbolIdx = symbols.indexOf(currentFocus.symbol);
      let nextFocus = null;

      // Queue Management für den nächsten Schritt
      let nextStepQueue = [...nextQueue]; 
      
      if (currentSymbolIdx < symbols.length - 1) {
        // Gleicher Zustand, nächstes Zeichen
        nextFocus = { 
          stateIdx: currentFocus.stateIdx, 
          symbol: symbols[currentSymbolIdx + 1] 
        };
      } else {
        // Zeichen für diesen Zustand fertig -> Entferne ihn vorne aus der Queue
        nextStepQueue.shift(); 
        
        if (nextStepQueue.length > 0) {
          nextFocus = {
            stateIdx: nextStepQueue[0],
            symbol: symbols[0]
          };
        }
      }

      const newState = {
        discoveredStates: nextDiscovered,
        queue: nextStepQueue,
        transitions: nextTransitions,
        currentFocus: nextFocus
      };

      setFeedback({ 
        type: 'success', 
        message: isNew 
          ? `Korrekt! Neuer Zustand ${formatSet(correctTarget)} gefunden.` 
          : `Richtig! Führt zum bekannten Zustand S${targetIdx}.`
      });

      setTimeout(() => {
        setHistory(prev => [...prev.slice(0, currentStepIndex + 1), newState]);
        setCurrentStepIndex(prev => prev + 1);
        setUserSelection([]);
        setFeedback(null);
        if (!nextFocus) setIsFinished(true);
      }, 1000);

    } else {
      setFeedback({ type: 'error', message: 'Das stimmt nicht. Verfolge die Pfeile oben genau.' });
    }
  };

  return (
    <div className="min-h-screen bg-slate-50 font-sans text-slate-800 flex flex-col">
      <header className="bg-white border-b px-6 py-4 flex justify-between items-center sticky top-0 z-10">
        <div className="flex items-center gap-3">
          <div className="bg-indigo-600 text-white p-2 rounded-lg"><Network size={24} /></div>
          <div>
            <h1 className="text-xl font-bold">Potenzmengenkonstruktion</h1>
            <p className="text-xs text-slate-500">Einfaches Beispiel: "Endet auf 10"</p>
          </div>
        </div>
        <button onClick={resetExercise} className="flex gap-2 px-3 py-2 text-sm bg-slate-100 rounded hover:bg-slate-200">
          <RefreshCw size={16} /> Neustart
        </button>
      </header>

      <main className="flex-1 max-w-6xl mx-auto w-full p-6 grid grid-cols-1 lg:grid-cols-12 gap-6">
        
        {/* VISUALISIERUNG */}
        <div className="lg:col-span-5 flex flex-col gap-6">
          <div className="bg-white rounded-xl shadow-sm border p-4 h-[300px] flex flex-col">
            <h3 className="font-bold text-slate-700 mb-2">1. Der NEA (Vorgabe)</h3>
            <div className="flex-1 relative bg-slate-50 rounded border">
               <NFAVisualizer config={config} activeStates={currentFocus ? discoveredStates[currentFocus.stateIdx] : []} />
            </div>
          </div>

          <div className="bg-white rounded-xl shadow-sm border p-4 h-[300px] flex flex-col">
            <h3 className="font-bold text-slate-700 mb-2">3. Der DEA (Ergebnis)</h3>
            <div className="flex-1 relative bg-slate-50 rounded border flex items-center justify-center">
              {discoveredStates.length > 0 ? (
                <DFAVisualizer states={discoveredStates} transitions={transitions} activeState={currentFocus?.stateIdx} nfaConfig={config} />
              ) : <span className="text-slate-400">Diagramm entsteht...</span>}
            </div>
          </div>
        </div>

        {/* ARBEITSBEREICH */}
        <div className="lg:col-span-7 flex flex-col gap-6">
          <div className="bg-white rounded-xl shadow-lg border overflow-hidden">
            <div className="h-1 bg-slate-100"><div className="h-full bg-indigo-600 transition-all" style={{ width: `${(discoveredStates.length * 25)}%` }}></div></div>
            
            <div className="p-8">
              {!isFinished && currentFocus ? (
                <>
                  <div className="flex justify-between items-end mb-6">
                    <div>
                       <span className="text-xs font-bold text-indigo-500">SCHRITT {currentStepIndex + 1}</span>
                       <h2 className="text-2xl font-bold mt-1">Wohin geht der Pfeil?</h2>
                    </div>
                    <button onClick={handleBack} disabled={currentStepIndex===0} className="p-2 hover:bg-slate-100 rounded disabled:opacity-30"><ChevronLeft/></button>
                  </div>

                  <div className="flex gap-4 mb-6 bg-indigo-50 p-4 rounded-lg items-center">
                     <div>Start: <span className="font-mono font-bold bg-white px-2 py-1 rounded border border-indigo-200">S{currentFocus.stateIdx} = {formatSet(discoveredStates[currentFocus.stateIdx])}</span></div>
                     <ArrowRight className="text-slate-400" />
                     <div>Eingabe: <span className="font-mono font-bold bg-slate-800 text-white w-8 h-8 inline-flex items-center justify-center rounded">{currentFocus.symbol}</span></div>
                  </div>

                  <p className="mb-4 text-slate-700 font-medium">Markiere alle erreichbaren Ziel-Zustände:</p>
                  <div className="flex flex-wrap gap-3 mb-6">
                    {config.states.map(sId => (
                      <button key={sId} onClick={() => handleToggleState(sId)} disabled={feedback?.type === 'success'}
                        className={`w-12 h-12 rounded-lg font-mono font-bold border-2 ${userSelection.includes(sId) ? 'bg-indigo-600 text-white border-indigo-600' : 'bg-white border-slate-200 text-slate-500 hover:border-indigo-400'}`}>
                        q{sId}
                      </button>
                    ))}
                    <button onClick={() => !feedback && setUserSelection([])} disabled={feedback?.type === 'success'}
                      className={`px-4 h-12 rounded-lg border-2 border-dashed font-medium text-sm ${userSelection.length===0 ? 'border-indigo-400 bg-indigo-50 text-indigo-700' : 'border-slate-300 text-slate-400'}`}>
                      Leere Menge ∅
                    </button>
                  </div>

                  {feedback && (
                    <div className={`mb-4 p-3 rounded flex gap-2 ${feedback.type==='success'?'bg-green-50 text-green-800':'bg-red-50 text-red-800'}`}>
                      {feedback.type==='success'?<Check size={20}/>:<X size={20}/>} {feedback.message}
                    </div>
                  )}

                  {!feedback && (
                    <button onClick={checkAnswer} className="w-full py-3 bg-slate-900 text-white font-bold rounded-lg shadow hover:bg-slate-800">
                      Prüfen
                    </button>
                  )}
                </>
              ) : (
                <div className="text-center py-10">
                   <div className="w-16 h-16 bg-green-100 text-green-600 rounded-full flex items-center justify-center mx-auto mb-4"><Check size={32}/></div>
                   <h2 className="text-2xl font-bold mb-2">Fertig!</h2>
                   <p className="text-slate-600">Du hast den Algorithmus erfolgreich durchgeführt.</p>
                </div>
              )}
            </div>
          </div>

          <div className="bg-white rounded-xl shadow-sm border p-6">
            <h3 className="font-bold text-slate-700 mb-4">2. Tabelle</h3>
            <table className="w-full text-sm text-left">
              <thead className="bg-slate-50 text-slate-500">
                <tr>
                  <th className="p-3">DEA Zustand</th>
                  <th className="p-3">Menge</th>
                  {config.alphabet.map(sym => <th key={sym} className="p-3 text-center">'{sym}'</th>)}
                </tr>
              </thead>
              <tbody className="divide-y">
                {discoveredStates.map((set, idx) => {
                  const isActive = currentFocus && currentFocus.stateIdx === idx;
                  return (
                    <tr key={idx} className={isActive ? 'bg-indigo-50' : ''}>
                      <td className="p-3 font-bold text-indigo-700">S{idx} {set.some(s=>config.finalStates.includes(s))&&<span className="text-red-500 text-xs">(End)</span>}</td>
                      <td className="p-3 font-mono text-slate-600">{formatSet(set)}</td>
                      {config.alphabet.map(sym => (
                        <td key={sym} className={`p-3 text-center border-l ${isActive && currentFocus.symbol === sym ? 'bg-yellow-100 font-bold' : ''}`}>
                          {transitions[idx]?.[sym] !== undefined ? `S${transitions[idx][sym]}` : '-'}
                        </td>
                      ))}
                    </tr>
                  )
                })}
              </tbody>
            </table>
          </div>
        </div>
      </main>
    </div>
  );
};

// --- VISUALISIERUNG (Angepasst für einfaches Beispiel) ---

const NFAVisualizer = ({ config, activeStates }) => (
  <svg viewBox="0 0 500 400" className="w-full h-full pointer-events-none select-none">
    <defs>
      <marker id="m-nfa" markerWidth="10" markerHeight="7" refX="32" refY="3.5" orient="auto"><polygon points="0 0, 10 3.5, 0 7" fill="#94a3b8"/></marker>
      <marker id="m-nfa-loop" markerWidth="10" markerHeight="7" refX="10" refY="3.5" orient="auto"><polygon points="0 0, 10 3.5, 0 7" fill="#94a3b8"/></marker>
    </defs>
    {/* Pfade für Einfaches Beispiel (3 Zustände in Reihe) */}
    <LoopPath x={100} y={200} label="0, 1" dir="top" /> {/* q0 Loop 0,1 bei nicht-det? Im Config ist 0->0, 1->0,1. Also loop 0,1 */}
    <LinePath x1={100} y1={200} x2={250} y2={200} label="1" /> {/* q0 -> q1 */}
    <LinePath x1={250} y1={200} x2={400} y2={200} label="0" /> {/* q1 -> q2 */}

    {config.states.map(id => {
      const {x, y, label} = config.layout[id];
      const active = activeStates?.includes(id);
      return (
        <g key={id} transform={`translate(${x},${y})`}>
          <circle r="20" fill={active?'#e0e7ff':'white'} stroke={active?'#4f46e5':'#64748b'} strokeWidth="2"/>
          {config.finalStates.includes(id) && <circle r="16" fill="none" stroke={active?'#4f46e5':'#64748b'} strokeWidth="1"/>}
          <text y="5" textAnchor="middle" className={`font-mono text-sm font-bold ${active?'fill-indigo-700':'fill-slate-600'}`}>{label}</text>
        </g>
      )
    })}
  </svg>
);

const DFAVisualizer = ({ states, transitions, activeState, nfaConfig }) => (
  <svg viewBox="0 0 400 400" className="w-full h-full select-none">
    <defs>
      <marker id="m-dfa" markerWidth="10" markerHeight="7" refX="32" refY="3.5" orient="auto"><polygon points="0 0, 10 3.5, 0 7" fill="#4338ca"/></marker>
      <marker id="m-dfa-loop" markerWidth="10" markerHeight="7" refX="10" refY="3.5" orient="auto"><polygon points="0 0, 10 3.5, 0 7" fill="#4338ca"/></marker>
    </defs>
    {Object.entries(transitions).map(([src, targets]) => (
      <React.Fragment key={src}>
        {Object.entries(targets).map(([sym, tIdx]) => {
           // Gruppierung simulieren wenn nötig, hier einfach alle zeichnen.
           // Besser: Gruppieren wie vorher
           return null; 
        })}
        {/* Simplified rendering loop just for grouping */}
        {Object.entries(groupByTarget(targets)).map(([t, syms]) => {
           const sIdx=parseInt(src), tIdx=parseInt(t);
           const p1 = getGridPos(sIdx), p2 = getGridPos(tIdx);
           const label = syms.join(',');
           const isLoop = sIdx===tIdx;
           return isLoop 
             ? <LoopPath key={src+t} x={p1.x} y={p1.y} label={label} dir="bottom" color="#4338ca" mId="m-dfa-loop"/>
             : <LinePath key={src+t} x1={p1.x} y1={p1.y} x2={p2.x} y2={p2.y} label={label} color="#4338ca" mId="m-dfa" curve={Math.abs(sIdx-tIdx)>1}/>
        })}
      </React.Fragment>
    ))}
    {states.map((set, idx) => {
      const {x, y} = getGridPos(idx);
      const active = idx === activeState;
      const isFin = set.some(s => nfaConfig.finalStates.includes(s));
      return (
        <g key={idx} transform={`translate(${x},${y})`}>
          <circle r="22" fill={active?'#fbbf24':'white'} stroke="#4338ca" strokeWidth={active?3:2}/>
          {isFin && <circle r="18" fill="none" stroke="#4338ca" strokeWidth="1"/>}
          <text y="5" textAnchor="middle" className="font-bold text-xs fill-indigo-900">S{idx}</text>
        </g>
      )
    })}
  </svg>
);

// Helpers
const groupByTarget = (targets) => {
  const g = {};
  Object.entries(targets).forEach(([s,t]) => { if(!g[t])g[t]=[]; g[t].push(s); });
  return g;
}
const getGridPos = (idx) => ({ x: 100 + (idx%2)*150, y: 100 + Math.floor(idx/2)*120 });

const LinePath = ({ x1, y1, x2, y2, label, curve, color="#94a3b8", mId="m-nfa" }) => {
  const mx=(x1+x2)/2, my=(y1+y2)/2;
  let d=`M ${x1} ${y1} L ${x2} ${y2}`, lx=mx, ly=my;
  if(curve) {
    const dx=x2-x1, dy=y2-y1;
    const cx=mx-dy*0.3, cy=my+dx*0.3;
    d=`M ${x1} ${y1} Q ${cx} ${cy} ${x2} ${y2}`;
    lx=cx*0.5+mx*0.5; ly=cy*0.5+my*0.5;
  }
  return (
    <g>
      <path d={d} fill="none" stroke={color} strokeWidth="2" markerEnd={`url(#${mId})`}/>
      <rect x={lx-8} y={ly-8} width="16" height="16" rx="4" fill="white" stroke={color}/>
      <text x={lx} y={ly+4} textAnchor="middle" className="text-xs font-bold font-mono" fill={color}>{label}</text>
    </g>
  )
}

const LoopPath = ({ x, y, label, dir='top', color="#94a3b8", mId="m-nfa-loop" }) => {
  const o = {top:{dx:0,dy:-1}, bottom:{dx:0,dy:1}}[dir] || {dx:0,dy:-1};
  const cp1x=x+o.dx*50-o.dy*30, cp1y=y+o.dy*50+o.dx*30;
  const cp2x=x+o.dx*50+o.dy*30, cp2y=y+o.dy*50-o.dx*30;
  return (
    <g>
      <path d={`M ${x} ${y} C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${x} ${y}`} fill="none" stroke={color} strokeWidth="2" markerEnd={`url(#${mId})`}/>
      <rect x={x+o.dx*45-10} y={y+o.dy*45-8} width="20" height="16" rx="4" fill="white" stroke={color}/>
      <text x={x+o.dx*45} y={y+o.dy*45+4} textAnchor="middle" className="text-xs font-bold font-mono" fill={color}>{label}</text>
    </g>
  )
}

export default NeaToDeaTrainer;
